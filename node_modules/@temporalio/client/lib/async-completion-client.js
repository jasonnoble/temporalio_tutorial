"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncCompletionClient = exports.ActivityCancelledError = exports.ActivityCompletionError = exports.ActivityNotFoundError = void 0;
const constants_1 = require("@grpc/grpc-js/build/src/constants");
const common_1 = require("@temporalio/common");
const internal_non_workflow_1 = require("@temporalio/common/lib/internal-non-workflow");
const base_client_1 = require("./base-client");
const errors_1 = require("./errors");
/**
 * Thrown by {@link AsyncCompletionClient} when trying to complete or heartbeat an Activity that does not exist in the
 * system.
 */
class ActivityNotFoundError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ActivityNotFoundError';
    }
}
exports.ActivityNotFoundError = ActivityNotFoundError;
/**
 * Thrown by {@link AsyncCompletionClient} when trying to complete or heartbeat
 * an Activity for any reason apart from {@link ActivityNotFoundError}.
 */
class ActivityCompletionError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ActivityCompletionError';
    }
}
exports.ActivityCompletionError = ActivityCompletionError;
/**
 * Thrown by {@link AsyncCompletionClient.heartbeat} when the Workflow has
 * requested to cancel the reporting Activity.
 */
class ActivityCancelledError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ActivityCancelledError';
    }
}
exports.ActivityCancelledError = ActivityCancelledError;
function defaultAsyncCompletionClientOptions() {
    return (0, base_client_1.defaultBaseClientOptions)();
}
/**
 * A client for asynchronous completion and heartbeating of Activities.
 *
 * Typically this client should not be instantiated directly, instead create the high level {@link Client} and use
 * {@link Client.activity} to complete async activities.
 */
class AsyncCompletionClient extends base_client_1.BaseClient {
    constructor(options) {
        super(options);
        this.options = {
            ...defaultAsyncCompletionClientOptions(),
            ...(0, internal_non_workflow_1.filterNullAndUndefined)(options ?? {}),
            loadedDataConverter: this.dataConverter,
        };
    }
    /**
     * Raw gRPC access to the Temporal service.
     *
     * **NOTE**: The namespace provided in {@link options} is **not** automatically set on requests made via this service
     * object.
     */
    get workflowService() {
        return this.connection.workflowService;
    }
    /**
     * Transforms grpc errors into well defined TS errors.
     */
    handleError(err) {
        if ((0, errors_1.isServerErrorResponse)(err)) {
            if (err.code === constants_1.Status.NOT_FOUND) {
                throw new ActivityNotFoundError('Not found');
            }
            throw new ActivityCompletionError(err.details || err.message);
        }
        throw new ActivityCompletionError('Unexpected failure');
    }
    async complete(taskTokenOrFullActivityId, result) {
        try {
            if (taskTokenOrFullActivityId instanceof Uint8Array) {
                await this.workflowService.respondActivityTaskCompleted({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    taskToken: taskTokenOrFullActivityId,
                    result: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, result) },
                });
            }
            else {
                await this.workflowService.respondActivityTaskCompletedById({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    ...taskTokenOrFullActivityId,
                    result: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, result) },
                });
            }
        }
        catch (err) {
            this.handleError(err);
        }
    }
    async fail(taskTokenOrFullActivityId, err) {
        try {
            if (taskTokenOrFullActivityId instanceof Uint8Array) {
                await this.workflowService.respondActivityTaskFailed({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    taskToken: taskTokenOrFullActivityId,
                    failure: await (0, internal_non_workflow_1.encodeErrorToFailure)(this.dataConverter, (0, common_1.ensureTemporalFailure)(err)),
                });
            }
            else {
                await this.workflowService.respondActivityTaskFailedById({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    ...taskTokenOrFullActivityId,
                    failure: await (0, internal_non_workflow_1.encodeErrorToFailure)(this.dataConverter, err),
                });
            }
        }
        catch (err) {
            this.handleError(err);
        }
    }
    async reportCancellation(taskTokenOrFullActivityId, details) {
        try {
            if (taskTokenOrFullActivityId instanceof Uint8Array) {
                await this.workflowService.respondActivityTaskCanceled({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    taskToken: taskTokenOrFullActivityId,
                    details: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, details) },
                });
            }
            else {
                await this.workflowService.respondActivityTaskCanceledById({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    ...taskTokenOrFullActivityId,
                    details: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, details) },
                });
            }
        }
        catch (err) {
            this.handleError(err);
        }
    }
    async heartbeat(taskTokenOrFullActivityId, details) {
        try {
            if (taskTokenOrFullActivityId instanceof Uint8Array) {
                const { cancelRequested } = await this.workflowService.recordActivityTaskHeartbeat({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    taskToken: taskTokenOrFullActivityId,
                    details: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, details) },
                });
                if (cancelRequested) {
                    throw new ActivityCancelledError('cancelled');
                }
            }
            else {
                const { cancelRequested } = await this.workflowService.recordActivityTaskHeartbeatById({
                    identity: this.options.identity,
                    namespace: this.options.namespace,
                    ...taskTokenOrFullActivityId,
                    details: { payloads: await (0, internal_non_workflow_1.encodeToPayloads)(this.dataConverter, details) },
                });
                if (cancelRequested) {
                    throw new ActivityCancelledError('cancelled');
                }
            }
        }
        catch (err) {
            if (err instanceof ActivityCancelledError) {
                throw err;
            }
            this.handleError(err);
        }
    }
}
exports.AsyncCompletionClient = AsyncCompletionClient;
//# sourceMappingURL=async-completion-client.js.map
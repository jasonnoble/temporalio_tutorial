"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertFromNamedError = exports.IllegalStateError = exports.UnexpectedError = exports.TransportError = exports.ShutdownError = void 0;
const common_1 = require("@temporalio/common");
Object.defineProperty(exports, "IllegalStateError", { enumerable: true, get: function () { return common_1.IllegalStateError; } });
/**
 * The worker has been shut down
 */
class ShutdownError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ShutdownError';
    }
}
exports.ShutdownError = ShutdownError;
/**
 * Thrown after shutdown was requested as a response to a poll function, JS should stop polling
 * once this error is encountered
 */
class TransportError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'TransportError';
    }
}
exports.TransportError = TransportError;
/**
 * Something unexpected happened, considered fatal
 */
class UnexpectedError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'UnexpectedError';
    }
}
exports.UnexpectedError = UnexpectedError;
function convertFromNamedError(e, keepStackTrace) {
    // Check if the error's class is exactly Error (not a descendant of it).
    // The instanceof check both ensure that e is indeed an object AND avoid
    // TypeScript from complaining on accessing Error properties.
    if (e instanceof Error && Object.getPrototypeOf(e).name === 'Error') {
        let newerr;
        switch (e.name) {
            case 'TransportError':
                newerr = new TransportError(e.message);
                newerr.stack = keepStackTrace ? e.stack : undefined;
                return newerr;
            case 'IllegalStateError':
                newerr = new common_1.IllegalStateError(e.message);
                newerr.stack = keepStackTrace ? e.stack : undefined;
                return newerr;
            case 'ShutdownError':
                newerr = new ShutdownError(e.message);
                newerr.stack = keepStackTrace ? e.stack : undefined;
                return newerr;
            case 'UnexpectedError':
                newerr = new UnexpectedError(e.message);
                newerr.stack = keepStackTrace ? e.stack : undefined;
                return newerr;
        }
    }
    return e;
}
exports.convertFromNamedError = convertFromNamedError;
//# sourceMappingURL=errors.js.map